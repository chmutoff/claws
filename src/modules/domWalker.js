var EXPORTED_SYMBOLS = ['DomWalker']
Components.utils.import('resource://claws/whitespaceHelper.js')

/**
 * DOM Walker is the core of the project
 * Begins with a root node (html or body) and walks through all the document.
 * Each node is processed by few functions to generate an output.
 *
 * @param {Object} textProvider must contain 3 basic functions to generate node output
 *          Functions: getText, getClosingText and getInputText
 *          This parameter allows to use different output modes
 *
 * @param {Window} sourceWindow references the window which contains the DOM to process         
 *
 * @returns {Object} which contains
 *          WalkDOM function
 *          linksList which contains Object{ text: 'linkText', url: 'linkUrl' }
 *          headingList list which contains Object{ text: 'headingText' }
 */
function DomWalker(textProvider, sourceWindow)
{
    // fields
    /** @private */ var _textProvider = textProvider
    /** @private */ var _sourceWindow = sourceWindow
    /** @private */ var _document = sourceWindow.content.document
    /** @public */  var _linkList = []
    /** @public */  var _headingList = []
    /** @public */  var _formsList = []
    
    
    // methods
    /**
     * Adds one link to the linksList while DOM is being processed.
     * 
     * Node can contain some elements like images and their alt text
     * must be shown. TextContent doesn´t have that text, so this function
     * just reuses WalkDom method with all the child nodes. After that,
     * all the output is merged and all the span nodes are removed (we don´t
     * need that text)
     *
     * @param {DOM Node} link node
     *
     * NOTE1: to avoid infinite loop, WalkDOM can´t receive the link node as
     * a parameter! It should always recive child nodes.
     *
     * NOTE2: There are 2 elements which are considered as a link: <a> and <area>     *
     */
    function addLink(node){
        // get link text including all important atribute info like img alt text
        var linkText = ''
        var children = node.childNodes
        for( var i=0; i<children.length; ++i )
        {
            var out = walkDOM(children[i])
            removeSpansFromNode(out)
            linkText += out.textContent
        }
        
        // Get link title from alt attribute of AREA tag
        linkText += ( node.hasAttribute('alt') ? node.alt : '' )
        var linkURL =  node.href // this returns the FULLY QUALIFIED url (getAttribute('href') returns the link as it is)
        linkText = ( linkText != '' ) ? cleanText(linkText) : 'url:' + linkURL // if link has no text show href text
        var item = {
            text : linkText,
            url : linkURL
        }
        _linkList.push(item)
    }
    
    /**
     * Adds one heading to the linksList while DOM is being processed.     *
     * The behavior of this function is the same as the addLink function.
     * 
     * @param {DOM Node} heading node     *
     */
    function addHeading(node){
        // get heading text including all important atribute info like img alt text
        var headingText = ''
        var children = node.childNodes
        for( var i=0; i<children.length; ++i )
        {
            var out = walkDOM(children[i])
            removeSpansFromNode(out)
            headingText += out.textContent
        }
        
        var item = {
            text : headingText
        }
        _headingList.push(item)
    }
    
    /**
     * Removes child span nodes
     *
     * @param {DOM Node} which needs to be cleaned
     */
    function removeSpansFromNode(node) {
        var spans = node.getElementsByTagName('span')
        var span
        while ((span = spans[0])) {
            span.parentNode.removeChild(span)
        }
    }
    
    /**
     * Appends text to the ouput generated by DomWalker()
     *
     * @param {string} this is added to the output
     * @param {DOM Node} the output, which is a <div> element
     */
    function appendTextToOutput(text, output){
        if ( text != '' ){
            var child = _document.createTextNode(text + ' ')
            output.appendChild(child)
        }
    }
    
    /**
     *
     
    function prependTextToOutput(text, output) {
        var firstChild = _document.createTextNode(text + ' ')
        output.insertBefore(firstChild, output.firstChild)        
    }*/
    
    /**
     * Appends <span>text</span> to output
     * Span can have special format, to distinguish generated output from plain text
     *
     * @param {string} this is added to the output
     * @param {DOM Node} the output, which is a <div> element
     */
    function appendSpanToOutput(text, output){
        if ( text != '' ){
            var spanNode = _document.createElement('span')
            spanNode.className = 'tag-output'
            var textNode = _document.createTextNode(text + ' ')
            spanNode.appendChild(textNode)
            output.appendChild(spanNode)
        }
    }
  
    /**
     * Returns relevant node information
     * i.e: image alt attribute text,
     *      input value,
     *      etc...
     *
     * @param {DOM Node} node to extract the information
     *
     * NOTE: all the tag names are transfromed to upper case because
     * depending on doctype they could be in lower/upper case
     */
    /*
    function getRelevantText(node){
        var tagName = node.tagName.toUpperCase()
      
        switch (tagName) {
            case 'AREA':
              return node.alt
            case 'IMG':
              return node.alt
            case 'INPUT':
                var inputType = node.type
                switch (inputType) {
                  case 'hidden':
                    return ''
                  case 'image':
                    return node.alt
                  case 'radio':
                    return ''
                  default:
                    return node.value
                }
            case 'SELECT':
              return node.value
            case 'TABLE':
              return node.summary
            default:
              return ''
        }
    }
    */
    
    /**
     * Determines whether the node should be excluded from expanding(walking)
     * Some of them are processed manually due to special characteristics (i.e Iframe or table)
     * 
     * @returns true if node should not be expanded
     * 
     * NOTE: all the tag names are transfromed to upper case because
     * depending on doctype they could be in lower/upper case
     */
    function isNodeExcluded(node) {
      var tag = node.tagName.toUpperCase()
     
        var excludedTagNames = [
            'AUDIO',    // Nothing to process here
            'BASE',     // specifies the base URL to use for all relative URLs contained within a document
            'CANVAS',   // draw graphics via scripting
            'DATA',     // Only in WHATWG version of HTML, not in W3C. Just in case...
            'EMBED',    // tag defines a container for an external application or interactive content (a plug-in)
            'HEAD',     // specifies the base URL to use for all relative URLs contained within a document
            'IFRAME',   // THIS IS EXPANDED MANUALLY
            'LINK',     // specifies relationships between the current document and an external resource
            'META',     // represents any metadata information that cannot be represented by one of the other HTML meta-related elements
            'NOSCRIPT',
            'OPTION',
            'PARAM',    // tag is used to define parameters for plugins embedded with an <object> element
            'SCRIPT',
            'STYLE',    // contains style information for a document, or a part of document
            'TABLE',    // THIS IS EXPANDED MANUALLY
            'TITLE',    // defines the title of the document, shown in a browser's title bar or on the page's tab
            'VIDEO'     // Nothing to process here   
        ]
        return ( excludedTagNames.indexOf(tag) > -1 )   
    }
  
    /** Determines whether the node is visible or not
     *
     * 1st case -> style="display:none"
     * 2nd case -> style="visibility:hidden"
     * 3rd case -> hidden="true"
     * 4th case -> computedStyle "display:none"
     * 5th case -> computedStyle "visibility:hidden"
     * Note: hidden inputs are controlled by input text functions
     *
     * AREA tag is hidden but ALWAYS must be processed
     *
     * @returns true if the node is not visible
     *
     * NOTE: there is no need to check node.style.display or node.style.visibility
     *      because getComputedStyle returns the real style of the element
     */
    function isNodeHidden(node){
        return (
            (node.hidden == true
            || _sourceWindow.getComputedStyle(node).display == 'none'
            || _sourceWindow.getComputedStyle(node).visibility == 'hidden') && node.tagName.toUpperCase() != 'AREA'
        )
    }
    
    /**
     * The CORE function! Iterates through DOM tree and generates the output
     * Only TEXT and ELEMENT nodes are processed
     * There is another type 'ClosingText' node which is piled when we need to
     * generate some output for closing tag
     *
     * @param {DOM Node} dom root node to begin with
     * @returns {DOM Node} output content     *
     */
    function walkDOM(dom){
        var nodeStack = new Array()
        var output = _document.createElement('div')
        output.className = 'output'
        cleanWhitespace(dom)
        nodeStack.push(dom)
      
        do{       
            var nodeToExpand = nodeStack.pop()
            
            // nodeType == 1 -> ELEMENT_NODE
            if ( nodeToExpand.nodeType == 1 && !isNodeHidden(nodeToExpand)) {
              
                var tagName =  nodeToExpand.tagName.toUpperCase()
                
                // process links
                if ( tagName == 'A' || tagName == 'AREA' ) {
                    addLink(nodeToExpand)
                }
                
                // count forms
                if ( tagName == 'FORM' ) {
                    _formsList.push(nodeToExpand)
                }
                
                // process heading (H1 - H6)
                var headingPattern = new RegExp('^H[1-6]$')
                if (headingPattern.test(tagName)) {
                    addHeading(nodeToExpand)
                }
                
                // insert tag text
                appendSpanToOutput(_textProvider.getText(nodeToExpand), output)
                
                // insert text of relevant attributes
                appendTextToOutput(_textProvider.getRelevantText(nodeToExpand), output)
                
                // insert closing tag var node with text if necesary
                var closingText = {
                    nodeType : 'closingText',
                    textContent : _textProvider.getClosingText(nodeToExpand)
                }
                if ( closingText.textContent != '' ){
                  nodeStack.push(closingText)
                } 
                
                // check if node needs to be expanded
                if ( !isNodeExcluded(nodeToExpand) ){
                    // expand node
                    nodeToExpand = nodeToExpand.lastChild
                    while(nodeToExpand){
                        nodeStack.push(nodeToExpand)
                        nodeToExpand = nodeToExpand.previousSibling
                    }
                }
                else if (nodeToExpand.tagName == 'TABLE'){
                    // get table rows in a correct order (tfoot can be before tbody)          
                    var rows = nodeToExpand.rows
                    // add rows to stack
                    for( var i=rows.length-1; i>=0; --i )
                    {
                        nodeStack.push(rows[i])        
                    }
                    // table can have a caption
                    if (nodeToExpand.getElementsByTagName('caption')[0] != null) {
                        nodeStack.push(nodeToExpand.getElementsByTagName('caption')[0])
                    }
                }
                else if (nodeToExpand.tagName == 'IFRAME'){
                    if(nodeToExpand.hasAttribute('src')){
                        cleanWhitespace(nodeToExpand.contentDocument.body)
                        nodeStack.push(nodeToExpand.contentDocument.body);
                    }
                    else appendTextToOutput('about:blank ', output)
                }
            }
            // nodeType == 3 -> TEXT_NODE    
            else if(nodeToExpand.nodeType == 3){
                // print textNode content
                appendTextToOutput(nodeToExpand.textContent + ' ', output)
            }
            // string contains tag closing text
            else if (nodeToExpand.nodeType == 'closingText'){
                appendSpanToOutput(nodeToExpand.textContent, output)
            }      
        }while(nodeStack.length > 0)
        
        /*
        // prepend document information like page title, number of links and forms, etc...
        var docInfo = {
            docTitle : _document.title,
            nOfLinks : _linkList.length,
            nOfForms : _nOfForms
        }
        prependTextToOutput(_textProvider.getIntroText(docInfo), output)
        */
        return output
    } // end of walkDOM fn
    
    return{
        walkDOM : walkDOM,
        linkList : _linkList,
        headingList: _headingList,
        formsList : _formsList
    } // end of return    
} // end of class definition
