var EXPORTED_SYMBOLS = ['DomWalker']
Components.utils.import('resource://claws/whitespaceHelper.js')

const { classes: Cc, interfaces: Ci, utils: Cu } = Components;
const {console} = Cu.import("resource://gre/modules/devtools/Console.jsm", {});

/**
 * DOM Walker is the core of the project
 * Begins with a root node (html or body) and walks through all the document.
 * Each node is processed by few functions to generate an output.
 *
 * @param {Object} textProvider must contain 3 basic functions to generate node output
 *          Functions: getText, getClosingText and getInputText
 *          This parameter allows to use different output modes
 *
 * @param {Window} sourceWindow references the window which contains the DOM to process         
 *
 * @returns {Object} which contains
 *          WalkDOM function
 *          linksList which contains Object{ text: 'linkText', url: 'linkUrl' }
 *          headingList list which contains Object{ text: 'headingText' }
 */
function DomWalker(textProvider, sourceWindow)
{
    // fields
    /** @private */ var _textProvider = textProvider
    /** @private */ var _sourceWindow = sourceWindow
    /** @private */ var _document = sourceWindow.content.document
    /** @public */  var _linkList = []
    /** @public */  var _headingList = []
    /** @public */  var _formsList = []
    
    
    // methods
    /**
     * Add one link to the linksList while DOM is being processed and
     * obtain the output for the link node which can be append to the
     * global output.
     * 
     * Node can contain some elements like images and their alt text
     * must be shown. TextContent doesn´t have that text, so this function
     * just reuses WalkDom method with all the child nodes. After that,
     * all the output is merged and all the span nodes are removed (we don´t
     * need that text)
     *
     * @param {DOM Node} link node
     * @return {DOM Node} output of processing the link node
     *
     * NOTE1: to avoid infinite loop, WalkDOM can´t receive the link node as
     * a parameter! It should always recive child nodes.
     *
     * NOTE2: There are 2 elements which are considered as a link: <a> and <area>
     */
    function addLink(node){
        // get link text including all important atribute info like img alt text
        var linkText = ''
        var children = node.childNodes
        var linkOutput = _document.createElement('span')
        linkOutput.className = 'link-text'
        for( var i=0; i<children.length; ++i ){
            var out = walkDOM(children[i])
            // append all the chlid nodes of out
            // (avoid adding parent node generated by walkDom <div class="otput">[childNodes]</div>)
            appendChildNodes(linkOutput, out)
            // remove all the tags and leave only the text
            removeSpansFromNode(out)
            linkText += out.textContent
        }
        
        // Get link title from alt attribute of AREA tag
        linkText += ( node.hasAttribute('alt') ? node.alt : '' )
        var linkURL =  node.href // this returns the FULLY QUALIFIED url (getAttribute('href') returns the link as it is)
        linkText = ( linkText != '' ) ? cleanText(linkText) : 'url:' + linkURL // if link has no text show href text
        var item = {
            text : linkText,
            url : linkURL
        }
        _linkList.push(item)
        
        return linkOutput
    }
    
    /**
     * Adds one heading to the linksList while DOM is being processed.
     * The behavior of this function is the same as the addLink function.
     * 
     * @param {DOM Node} heading node
     */
    function addHeading(node){
        // get heading text including all important atribute info like img alt text
        var headingText = ''
        var children = node.childNodes
        var headingOutput = _document.createElement('span')
        headingOutput.className = 'heading-text'
        for( var i=0; i<children.length; ++i )
        {
            var out = walkDOM(children[i])
            // append all the chlid nodes of out
            // (avoid adding parent node generated by walkDom <div class="otput">[childNodes]</div>)
            appendChildNodes(headingOutput, out)
            // remove all the tags and leave only the text
            removeSpansFromNode(out)            
            headingText += out.textContent
        }
        
        var cleanHeadingText = cleanText(headingText)        
        var item = {
            text : cleanHeadingText,
            level : node.tagName.toUpperCase()
        }
        _headingList.push(item)
        
        return headingOutput
    }
    
    /**
     * Remove nodes with .tag-output class
     * Those nodes contains tags announcements which shouldn´t be visible
     * in links lins and heading list
     *
     * @param {DOM Node} Node to be cleaned
     */
    function removeSpansFromNode(node) {
        var spans = node.getElementsByClassName('tag-output')
        var span
        while ((span = spans[0])) {
            span.parentNode.removeChild(span)
        }
    }
    
    /**
     *  Append all the child nodes from source node to destiny node
     */
    function appendChildNodes(dst, src){
        var children = src.childNodes
        for( var i=0; i<children.length; ++i){
            dst.appendChild(children[i].cloneNode(true))
        }
    }
    
    /**
     * Append text to the ouput generated by DomWalker()
     *
     * @param {string} this is added to the output
     * @param {DOM Node} the output, which should be a <div> element
     */
    function appendTextToOutput(text, output){
        if ( text != '' ){
            var child = _document.createTextNode(text + ' ')
            output.appendChild(child)
        }
    }
    
    /**
     * Appends <span class="tag-output">text</span> to output
     * Span can have special format, to distinguish generated output from plain text
     *
     * @param {string} this is added to the output
     * @param {DOM Node} the output, which should be a <div> element
     */
    function appendSpanToOutput(text, output, className = ''){
        if ( text != '' ){
            var spanNode = _document.createElement('span')
            spanNode.className = 'tag-output '+className
            var textNode = _document.createTextNode(text + ' ')
            spanNode.appendChild(textNode)
            output.appendChild(spanNode)
        }
    }
    
    function getTagOutputClass(tagName) {
        switch (tagName) {
            case 'H1':
            case 'H2':
            case 'H3':
            case 'H4':
            case 'H5':
            case 'H6':
                return 'heading'
            default:
                return ''
        }
    }
    
    /**
     * Determine whether the node should be excluded from expanding(walking) or not.
     * Node tag name won´t be excluded from announcing, only it´s content.
     * 
     * @returns true if node should not be expanded
     * 
     * NOTE: all the tag names are transfromed to upper case because
     * depending on doctype they could be in lower/upper case
     */
    function isNodeExcluded(node) {
      var tag = node.tagName.toUpperCase()
     
        var excludedTagNames = [            
            'AUDIO',    // Nothing to process here
            'BASE',     // specifies the base URL to use for all relative URLs contained within a document
            'CANVAS',   // draw graphics via scripting
            'DATA',     // Only in WHATWG version of HTML, not in W3C. Just in case...
            'EMBED',    // defines a container for an external application or interactive content (a plug-in)
            'HEAD',     // specifies the base URL to use for all relative URLs contained within a document
            'LINK',     // specifies relationships between the current document and an external resource
            'META',     // represents any metadata information that cannot be represented by one of the other HTML meta-related elements
            'NOSCRIPT', // defines a section of html to be inserted if a script type on the page is unsupported or if scripting is currently turned off in the browser
            'OPTION',   // is used to create a control representing an item within a <select>, an <optgroup> or a <datalist> HTML5 element
            'PARAM',    // is used to define parameters for plugins embedded with an <object> element
            'SCRIPT',   // is used to embed or reference an executable script within an HTML or XHTML document
            'STYLE',    // contains style information for a document, or a part of document
            'TITLE',    // defines the title of the document, shown in a browser's title bar or on the page's tab
            'VIDEO'     // Nothing to process here   
        ]
        return ( excludedTagNames.indexOf(tag) > -1 )   
    }
    
    /**
     * Determines if child nodes are expanded by walkDom or in some special way
     */
    function isNodeExpandedSeparately(node)
    {
        var tag = node.tagName.toUpperCase()
     
        var tagNames = [
            'A',
            'AREA',
            'H1',
            'H2',
            'H3',
            'H4',
            'H5',
            'H6',
            'IFRAME',
            'TABLE'
        ]
        
        return ( tagNames.indexOf(tag) > -1 )
    }
  
    /** 
     * Determines whether the node is visible or not
     * 1st case -> style="display:none"
     * 2nd case -> style="visibility:hidden"
     * 3rd case -> hidden="true"
     * 4th case -> computedStyle "display:none"
     * 5th case -> computedStyle "visibility:hidden"
     * Note: hidden inputs are controlled by input text functions
     *
     * AREA tag is hidden but ALWAYS must be processed
     *
     * @returns true if the node is not visible
     *
     * NOTE: there is no need to check node.style.display or node.style.visibility
     *      because getComputedStyle returns the real style of the element
     */
    function isNodeHidden(node){
        return (
            (node.hidden == true
            || _sourceWindow.getComputedStyle(node).display == 'none'
            || _sourceWindow.getComputedStyle(node).visibility == 'hidden') && node.tagName.toUpperCase() != 'AREA'
        )
    }
    
    /**
     * The CORE function! Iterates through DOM tree and generates the output
     * Only TEXT and ELEMENT DOM nodes are processed
     * There is another type 'ClosingText' node which is piled for closing tag
     *
     * @param {DOM Node} DOM root node to begin with
     * @returns {DOM Node} output content
     */
    function walkDOM(dom){        
        var nodeStack = new Array()
        var langStack = new Array()
        var output = _document.createElement('div')
        output.className = 'output'
        cleanWhitespace(dom)
        nodeStack.push(dom)
        
        var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                    .getService(Components.interfaces.nsIPrefService).getBranch("extensions.claws.output.");

        var defLang = (_document.documentElement.lang != '') ? _document.documentElement.lang : prefs.getCharPref("default.lang")

        langStack.push(defLang)

        do{       
            var nodeToExpand = nodeStack.pop()
            
            // nodeType == 1 -> ELEMENT_NODE
            if ( nodeToExpand.nodeType == 1 && !isNodeHidden(nodeToExpand)) {
              
                var tagName =  nodeToExpand.tagName.toUpperCase()
                
                // insert opening tag text
                var tagOutputClass = getTagOutputClass(tagName)   
                appendSpanToOutput(_textProvider.getText(nodeToExpand), output, tagOutputClass)
                
                // process heading (H1 - H6)
                var headingPattern = new RegExp('^H[1-6]$')
                if (headingPattern.test(tagName)) {
                    var headingOutput = addHeading(nodeToExpand)
                    output.appendChild(headingOutput)
                }
                
                // count forms
                if ( tagName == 'FORM' ) {
                    _formsList.push(nodeToExpand)
                }
                
                // ARIA role attribute
                if (nodeToExpand.hasAttribute('role')) {
                    appendSpanToOutput(_textProvider.getAriaLandmarkText(nodeToExpand.getAttribute('role')), output)
                }
                
                // insert text of relevant attributes
                appendTextToOutput(_textProvider.getRelevantText(nodeToExpand), output)
                
                // detect language change
                if (nodeToExpand.hasAttribute('lang')) {
                    let newLang = nodeToExpand.getAttribute('lang')
                    let currentLang = langStack.slice().pop()
                    if ( currentLang != newLang ) {
                        appendSpanToOutput(textProvider.getLangChangeText(currentLang, newLang), output)
                    }
                    langStack.push(newLang)
                }
                
                // insert closing tag as var node
                var closingText = {
                    nodeType : 'closingText',
                    tagName : tagName,
                    lang : ( nodeToExpand.hasAttribute('lang') ? nodeToExpand.getAttribute('lang') : '' ),
                    role : ( nodeToExpand.hasAttribute('role') ? nodeToExpand.getAttribute('role') : '' ),
                    textContent : _textProvider.getClosingText(nodeToExpand)
                }
                nodeStack.push(closingText)
                
                // check if node needs to be expanded
                if ( !isNodeExcluded(nodeToExpand) && !isNodeExpandedSeparately(nodeToExpand) ){
                    // expand node
                    nodeToExpand = nodeToExpand.lastChild
                    while(nodeToExpand){
                        nodeStack.push(nodeToExpand)
                        nodeToExpand = nodeToExpand.previousSibling
                    }
                }
                // custom expanding
                else{
                    // process link
                    if ( tagName == 'A' || tagName == 'AREA' ) {
                        var linkOutput = addLink(nodeToExpand)
                        output.appendChild(linkOutput)
                    }                
                    // process iframe
                    else if (tagName == 'IFRAME'){
                        if(nodeToExpand.hasAttribute('src')){
                            cleanWhitespace(nodeToExpand.contentDocument.body)
                            nodeStack.push(nodeToExpand.contentDocument.body);
                        }
                        else appendTextToOutput(' about:blank ', output)
                    }
                    // process table
                    else if (tagName == 'TABLE'){
                        // get table rows in a correct order (tfoot can be before tbody)          
                        var rows = nodeToExpand.rows
                        // add rows to stack
                        for( var i=rows.length-1; i>=0; --i )
                        {
                            nodeStack.push(rows[i])        
                        }
                        // table can have a caption
                        if (nodeToExpand.getElementsByTagName('caption')[0] != null) {
                            nodeStack.push(nodeToExpand.getElementsByTagName('caption')[0])
                        }
                    }
                }
            }
            // nodeType == 3 -> TEXT_NODE    
            else if(nodeToExpand.nodeType == 3){
                appendTextToOutput(nodeToExpand.textContent, output)
            }
            // object -> CLOSING_NODE {virtual node}
            else if (nodeToExpand.nodeType == 'closingText'){
                // detect language change
                if (nodeToExpand.lang != '') {
                    let currentLang = langStack.pop()
                    let newLang = langStack.slice().pop()
                    if (newLang != currentLang) {
                        appendSpanToOutput(textProvider.getLangChangeText(currentLang, newLang), output)
                    }
                }
                if (nodeToExpand.role != '') {
                     appendSpanToOutput(textProvider.getClosingAriaLandmarkText(nodeToExpand.role), output)
                }
                // append closing text for some nodes
                appendSpanToOutput(nodeToExpand.textContent, output)
            }      
        }while(nodeStack.length > 0)
        return output
    } // end of walkDOM fn
    
    return{
        walkDOM : walkDOM,
        linkList : _linkList,
        headingList: _headingList,
        formsList : _formsList
    }
    
} // end of class definition
